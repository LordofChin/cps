package hw1;

import java.util.ArrayList;
//import time for timing operations
import java.time.LocalTime;
import java.util.Scanner;

public class FullKnapSack {
    private KnapSack ks;
    private Subsets subsets;
    private ArrayList<Item> optimalPacking;

    // autogenerated constructor from filename
    public FullKnapSack(String filename) {
        this.ks = new KnapSack(filename);
        this.subsets = new Subsets(ks.getItems());
        this.optimalPacking = findOptimalPacking(this);
    }

    // main method to drive the program and output results
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the input file name: ");
        String filename = sc.nextLine();

        LocalTime before = LocalTime.now(); // get before time for timing before any compute occurs

        FullKnapSack fullKS = new FullKnapSack(filename); // instantiate autogenerated FullKnapSack object
        System.out.println(fullKS.getKS()); // print out the knapsack info with built in toString method.

        System.out.println("Finding optimal packing ....");

        if (fullKS.getOptimalPacking().size() == 0) // check for optimal packing  
            System.out.println("No packing is found!"); 
        else // expected case where optimal packing is found
        {
            System.out.printf("Found a packing!\nTotal weight: %.2f\nTotal size: %.2f\nTotal value: %.2f\n%s\n",
                calculateWeight(fullKS.getOptimalPacking()),
                calculateSize(fullKS.getOptimalPacking()),
                calculateValue(fullKS.getOptimalPacking()),
                fullKS.optimalPackingToString()
            );
        }
        System.out.println(fullKS.getSubsets()); //debug line

        LocalTime after = LocalTime.now(); // get after time for timing after all compute occurs

        //output timing results from nano to seconds
        System.out.println("Total running time: " + ((after.getNano() - before.getNano())/1000000000.0) + " seconds");
    }


    public static ArrayList<Item> findOptimalPacking(FullKnapSack fullKS) 
    {
        // create a subset of only valid subsets (those that match weight and size constraints exactly)
        ArrayList<ArrayList<Item>> validSubsets = new ArrayList<ArrayList<Item>>();

        for (ArrayList<Item> subset : fullKS.getSubsets().getSubsets()) {
            if (calculateWeight(subset) == fullKS.getKS().getWeight() && calculateSize(subset) == fullKS.getKS().getSize())
                validSubsets.add(subset);
        }

        // find the optimal packing among valid subsets
        ArrayList<Item> optimalPacking = new ArrayList<Item>();
        float maxValue = 0;
        for (ArrayList<Item> subset : validSubsets) {
            float value = calculateValue(subset);
            if (value > maxValue) {
                maxValue = value;
                optimalPacking = subset;
            }
        }
        return optimalPacking;
    }

// All/most code below this point is LLM auto-completed code for helpers, getters, setters, and/or toString methods.
// helper methods to find optimal packing
    public static float calculateValue(ArrayList<Item> items) 
    {
        float totalValue = 0;
        for (Item i : items) {
            totalValue += i.getValue();
        }
        return totalValue;
    }

    public static float calculateWeight(ArrayList<Item> items) 
    {
        float totalWeight = 0;
        for (Item i : items) {
            totalWeight += i.getWeight();
        }
        return totalWeight;
    }

    public static float calculateSize(ArrayList<Item> items) 
    {
        float totalSize = 0;
        for (Item i : items) {
            totalSize += i.getSize();
        }
        return totalSize;
    }

    //setters and getters
    public KnapSack getKS() 
    {
        return ks;
    }
    public void setKS(KnapSack ks) 
    {
        this.ks = ks;
    }
    public Subsets getSubsets() 
    {
        return subsets;
    }
    public void setSubsets(Subsets subsets) 
    {
        this.subsets = subsets;
    }
    public ArrayList<Item> getOptimalPacking() {
        return optimalPacking;
    }
    public void setOptimalPacking(ArrayList<Item> optimalPacking) 
    {
        this.optimalPacking = optimalPacking;
    }

    public String optimalPackingToString() 
    {
        StringBuilder sb = new StringBuilder();
        sb.append("Packing: ");
        for (int i = 0; i < this.getOptimalPacking().size(); i++) 
        {
            sb.append(this.getOptimalPacking().get(i).getName().toString() + (i < this.getOptimalPacking().size() - 1 ? ", " : ""));
        }
        return sb.toString();
    }
}
